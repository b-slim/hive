commit db577dae56a29e27b67891e1a520ebe262651fbe
Author: Slim Bouguerra <bslim@apache.org>
Date:   Fri Mar 29 19:44:01 2019 -0700

    clean up the code and some refactor
    
    Change-Id: Ie874b1640c8aab1c75eaa8ea63e9830bd2de3edc

diff --git a/llap-server/src/java/org/apache/hadoop/hive/llap/cache/BuddyAllocator.java b/llap-server/src/java/org/apache/hadoop/hive/llap/cache/BuddyAllocator.java
index 5f83a930d5..07aa9e2773 100644
--- a/llap-server/src/java/org/apache/hadoop/hive/llap/cache/BuddyAllocator.java
+++ b/llap-server/src/java/org/apache/hadoop/hive/llap/cache/BuddyAllocator.java
@@ -276,12 +276,25 @@ public void allocateMultiple(MemoryBuffer[] dest, int size, BufferObjectFactory
 
     // Note: we might want to be smarter if threadId-s are low and there more arenas than threads.
     long threadId = arenaCount > 1 ? Thread.currentThread().getId() : 0;
-    int startArenaIx = (int)(threadId  % arenaCount);
+    int startArenaIx ;
     int prevAllocIx = 0;
     int destAllocIx = 0;
-    int fastAttempt = 0;
-    while (fastAttempt < MAX_DISCARD_ATTEMPTS) {
-      startArenaIx = (int)((threadId + fastAttempt) % arenaCount);
+    int attempt = 0;
+    // We called reserveMemory so we know that there's memory waiting for us somewhere.
+    // However, we have a class of rare race conditions related to the order of locking/checking of
+    // different allocation areas. Simple case - say we have 2 arenas, 256Kb available in arena 2.
+    // We look at arena 1; someone deallocs 256Kb from arena 1 and allocs the same from arena 2;
+    // we look at arena 2 and find no memory. Or, for single arena, 2 threads reserve 256k each,
+    // and a single 1Mb block is available. When the 1st thread locks the 1Mb freelist, the 2nd one
+    // might have already examined the 256k and 512k lists, finding nothing. Blocks placed by (1)
+    // into smaller lists after its split is done will not be found by (2); given that freelist
+    // locks don't overlap, (2) may even run completely between the time (1) takes out the 1Mb
+    // block and the time it returns the remaining 768Kb.
+
+    // The way to get around this is by retrying and force evicting if needed.
+
+    while (attempt < MAX_DISCARD_ATTEMPTS) {
+      startArenaIx = (int)((threadId + attempt) % arenaCount);
       destAllocIx =
           allocateFast(dest,
               null,
@@ -294,7 +307,14 @@ public void allocateMultiple(MemoryBuffer[] dest, int size, BufferObjectFactory
       metrics.incAllocatorFastAllocation((destAllocIx - prevAllocIx) * allocationSize);
       if (destAllocIx == dest.length)
         return;
-
+      if (attempt == 0) {
+        // Try to allocate memory if we haven't allocated all the way to maxSize yet; very rare.
+        prevAllocIx = destAllocIx;
+        destAllocIx = allocateWithExpand(
+            dest, destAllocIx, freeListIx, allocationSize, arenaCount);
+        metrics.incrAllocationWithExpand((destAllocIx - prevAllocIx ) * allocationSize);
+        if (destAllocIx == dest.length) return;
+      }
       destAllocIx =
           allocateWithSplit(dest,
               null,
@@ -306,27 +326,18 @@ public void allocateMultiple(MemoryBuffer[] dest, int size, BufferObjectFactory
               arenaCount,
               -1);
       metrics.incrAllocationWithSplits((destAllocIx - prevAllocIx) * allocationSize);
-      if (destAllocIx == dest.length)
-        return;
-
-      if (fastAttempt == 0) {
-        // Try to allocate memory if we haven't allocated all the way to maxSize yet; very rare.
-        prevAllocIx = destAllocIx;
-        destAllocIx = allocateWithExpand(
-            dest, destAllocIx, freeListIx, allocationSize, arenaCount);
-        metrics.incrAllocationWithExpand((destAllocIx - prevAllocIx ) * allocationSize);
-        if (destAllocIx == dest.length) return;
-      }
-
-      if (fastAttempt >= 5 && fastAttempt < 15) {
-        long evicted = memoryManager.evictMemory(allocationSize << (fastAttempt - 5));
-        metrics.incAllocatorFreeListEvictedBytes(evicted);
-      } else if (fastAttempt >= 15) {
-        long targetBlockSize = Math.min(maxAllocation, allocationSize << (fastAttempt - 15) / 2);
+      if (destAllocIx == dest.length) return;
+
+      if (attempt >= 5 && attempt < 15) {
+        long evicted = memoryManager.evictMemory(allocationSize << (attempt - 5));
+        metrics.incAllocatorForceEvictedBytes(evicted);
+        metrics.incrAllocationEvictionAttempts(1);
+      } else if (attempt >= 15) {
+        long targetBlockSize = Math.min(maxAllocation, allocationSize << (attempt - 15) / 2);
         int nBlocks = memoryManager.evictNBlocks(targetBlockSize, dest.length - destAllocIx);
-        metrics.incAllocatorBruteForceEvictedBytes(nBlocks * targetBlockSize);
+        metrics.incAllocatorForceEvictedBlocksBytes(nBlocks * targetBlockSize);
       }
-      fastAttempt++;
+      attempt++;
       metrics.incrAllocationAttempt(1);
     }
 
@@ -340,108 +351,11 @@ public void allocateMultiple(MemoryBuffer[] dest, int size, BufferObjectFactory
 
     if (dest.length - destAllocIx > 0) {
       String msg = "Failed to allocate " + size + "; at " + destAllocIx + " out of "
-          + dest.length + " (entire cache is fragmented and locked, or an internal issue) after: " + fastAttempt + " attempts";
+          + dest.length + " (entire cache is fragmented and locked, or an internal issue) after: " + attempt + " attempts";
       logOomErrorMessage(msg);
       throw new AllocatorOutOfMemoryException(msg);
     }
 
-    // We called reserveMemory so we know that there's memory waiting for us somewhere.
-    // However, we have a class of rare race conditions related to the order of locking/checking of
-    // different allocation areas. Simple case - say we have 2 arenas, 256Kb available in arena 2.
-    // We look at arena 1; someone deallocs 256Kb from arena 1 and allocs the same from arena 2;
-    // we look at arena 2 and find no memory. Or, for single arena, 2 threads reserve 256k each,
-    // and a single 1Mb block is available. When the 1st thread locks the 1Mb freelist, the 2nd one
-    // might have already examined the 256k and 512k lists, finding nothing. Blocks placed by (1)
-    // into smaller lists after its split is done will not be found by (2); given that freelist
-    // locks don't overlap, (2) may even run completely between the time (1) takes out the 1Mb
-    // block and the time it returns the remaining 768Kb.
-    // Two solutions to this are some form of cross-thread helping (threads putting "demand"
-    // into some sort of queues that deallocate and split will examine), or having and "actor"
-    // allocator thread (or threads per arena).
-    // The 2nd one is probably much simpler and will allow us to get rid of a lot of sync code.
-    // But for now we will just retry. We will evict more each time.
-    int attempt = 0;
-    boolean isFailed = false;
-    int memoryFreeListReleased = 0;
-    int memoryBruteForceReleased = 0;
-    try {
-      int discardFailed = 0;
-      while (true) {
-       /* // Try to split bigger blocks.
-        int startArenaIx = (int)((threadId + attempt) % arenaCount);
-        int prevAllocIx = destAllocIx;
-        destAllocIx = allocateWithSplit(dest, null, destAllocIx, dest.length,
-            freeListIx, allocationSize, startArenaIx, arenaCount, -1);
-        metrics.incrAllocationWithSplits((destAllocIx - prevAllocIx ) * allocationSize);
-        if (destAllocIx == dest.length) return;*/
-
-        if (attempt == 0) {
-          // Try to allocate memory if we haven't allocated all the way to maxSize yet; very rare.
-          prevAllocIx = destAllocIx;
-          destAllocIx = allocateWithExpand(
-              dest, destAllocIx, freeListIx, allocationSize, arenaCount);
-          metrics.incrAllocationWithExpand((destAllocIx - prevAllocIx ) * allocationSize);
-          if (destAllocIx == dest.length) return;
-        }
-
-        // Try to force-evict the fragments of the requisite size.
-        boolean hasDiscardedAny = false;
-        DiscardContext ctx = threadCtx.get();
-        // Brute force may discard up to twice as many buffers.
-        int maxListSize = 1 << (doUseBruteDiscard ? freeListIx : (freeListIx - 1));
-        int requiredBlocks = dest.length - destAllocIx;
-        ctx.init(maxListSize, requiredBlocks);
-        // First, try to use the blocks of half size in every arena.
-        if (doUseFreeListDiscard && freeListIx > 0) {
-          discardBlocksBasedOnFreeLists(freeListIx, startArenaIx, arenaCount, ctx);
-          memoryFreeListReleased += ctx.memoryReleased;
-          hasDiscardedAny = ctx.resultCount > 0;
-          prevAllocIx = destAllocIx;
-          destAllocIx = allocateFromDiscardResult(dest, destAllocIx, freeListIx, allocationSize, ctx);
-          metrics.incrAllocationFromFreeListDiscard((destAllocIx - prevAllocIx ) * allocationSize);
-          if (destAllocIx == dest.length) return;
-        }
-        // Then, try the brute force search for something to throw away.
-        if (doUseBruteDiscard) {
-          ctx.resetResults();
-          discardBlocksBruteForce(freeListIx, startArenaIx, arenaCount, ctx);
-          memoryBruteForceReleased += ctx.memoryReleased;
-          hasDiscardedAny = hasDiscardedAny || (ctx.resultCount > 0);
-          prevAllocIx = destAllocIx;
-          destAllocIx = allocateFromDiscardResult(dest, destAllocIx, freeListIx, allocationSize, ctx);
-          metrics.incrAllocationFromBruteDiscard((destAllocIx - prevAllocIx ) * allocationSize);
-          if (destAllocIx == dest.length) return;
-        }
-
-        if (hasDiscardedAny) {
-          discardFailed = 0;
-        } else if (++discardFailed > MAX_DISCARD_ATTEMPTS) {
-          isFailed = true;
-          // Ensure all-or-nothing allocation.
-          for (int i = 0; i < destAllocIx; ++i) {
-            try {
-              deallocate(dest[i]);
-            } catch (Throwable t) {
-              LlapIoImpl.LOG.info("Failed to deallocate after a partially successful allocate: " + dest[i]);
-            }
-          }
-          /*String msg = "Failed to allocate " + size + "; at " + destAllocIx + " out of "
-              + dest.length + " (entire cache is fragmented and locked, or an internal issue)";
-          logOomErrorMessage(msg);
-          throw new AllocatorOutOfMemoryException(msg);*/
-        }
-        ++attempt;
-        metrics.incrAllocationAttempt(1);
-      }
-    } finally {
-      metrics.incAllocatorBruteForceEvictedBytes(memoryBruteForceReleased);
-      metrics.incAllocatorFreeListEvictedBytes(memoryFreeListReleased);
-      memoryManager.releaseMemory(memoryFreeListReleased + memoryBruteForceReleased);
-      if (!isFailed && attempt >= LOG_DISCARD_ATTEMPTS && (memoryFreeListReleased | memoryBruteForceReleased) > 0) {
-        LlapIoImpl.LOG.info("Allocation of " + dest.length + " buffers of size " + size + " took "
-            + attempt + " attempts to free enough memory; free list " + memoryFreeListReleased + " brutForce " + memoryBruteForceReleased);
-      }
-    }
   }
 
   /** The context for the forced eviction of buffers. */
diff --git a/llap-server/src/java/org/apache/hadoop/hive/llap/cache/LowLevelCacheMemoryManager.java b/llap-server/src/java/org/apache/hadoop/hive/llap/cache/LowLevelCacheMemoryManager.java
index fdea903fc3..5c3769e95a 100644
--- a/llap-server/src/java/org/apache/hadoop/hive/llap/cache/LowLevelCacheMemoryManager.java
+++ b/llap-server/src/java/org/apache/hadoop/hive/llap/cache/LowLevelCacheMemoryManager.java
@@ -148,7 +148,7 @@ public boolean reserveMemory(final long memoryToReserve,
     }
     metrics.incrCacheCapacityUsed(reservedTotalMetric - evictedTotalMetric);
     metrics.incrCacheEvictedBytes(evictedTotalMetric);
-    metrics.incrCacheTotalReserved(reservedTotalMetric); // this will show if we are reserving as much as we have to allocate
+    metrics.incrCacheTotalReserved(reservedTotalMetric);
     return result;
   }
 
diff --git a/llap-server/src/java/org/apache/hadoop/hive/llap/io/api/impl/LlapIoImpl.java b/llap-server/src/java/org/apache/hadoop/hive/llap/io/api/impl/LlapIoImpl.java
index f1dfa89933..4be6c80de9 100644
--- a/llap-server/src/java/org/apache/hadoop/hive/llap/io/api/impl/LlapIoImpl.java
+++ b/llap-server/src/java/org/apache/hadoop/hive/llap/io/api/impl/LlapIoImpl.java
@@ -151,8 +151,7 @@ private LlapIoImpl(Configuration conf) throws IOException {
         cachePolicyWrapper = cp;
       }
       // Allocator uses memory manager to request memory, so create the manager next.
-      this.memoryManager = new LowLevelCacheMemoryManager(
-          totalMemorySize, cachePolicyWrapper, cacheMetrics);
+      this.memoryManager = new LowLevelCacheMemoryManager(totalMemorySize, cachePolicyWrapper, cacheMetrics);
       cacheMetrics.setCacheCapacityTotal(totalMemorySize);
       // Cache uses allocator to allocate and deallocate, create allocator and then caches.
       BuddyAllocator allocator = new BuddyAllocator(conf, memoryManager, cacheMetrics);
diff --git a/llap-server/src/java/org/apache/hadoop/hive/llap/metrics/LlapDaemonCacheInfo.java b/llap-server/src/java/org/apache/hadoop/hive/llap/metrics/LlapDaemonCacheInfo.java
index 261a964f15..2c4c097105 100644
--- a/llap-server/src/java/org/apache/hadoop/hive/llap/metrics/LlapDaemonCacheInfo.java
+++ b/llap-server/src/java/org/apache/hadoop/hive/llap/metrics/LlapDaemonCacheInfo.java
@@ -37,7 +37,7 @@
   CacheReadRequests("Number of disk range requests to cache"),
   CacheAllocatedArena("Number of arenas allocated"),
   CacheNumLockedBuffers("Number of locked buffers in cache"),
-  AllocatorBruteForceEvictedBytes("Total bytes evicted using brute force discard"),
+  AllocatorForceEvictedBlocksBytes("Total bytes evicted using an exact block size"),
   AllocatorFreeListEvictedBytes("Total bytes evicted using free list discrad"),
   AllocatorTotalAllocated("Total Number of bytes allocated"),
   AllocatorFastAllocatedBytes("Total Number of fast allocated bytes"),
@@ -47,7 +47,7 @@
   AllocationFromFreeListDiscard("AllocationFromFreeListDiscard"),
   AllocationFromBruteDiscard("AllocationFromBruteDiscard"),
   AllocationAttempt("AllocationAttempt"),
-  CacheEvictedTotalBytes("Total evicted data by policy");
+  CacheEvictedTotalBytes("Total evicted data by calling reserve");
   private final String desc;
 
   LlapDaemonCacheInfo(String desc) {
diff --git a/llap-server/src/java/org/apache/hadoop/hive/llap/metrics/LlapDaemonCacheMetrics.java b/llap-server/src/java/org/apache/hadoop/hive/llap/metrics/LlapDaemonCacheMetrics.java
index c3e8fe7119..8aff717b02 100644
--- a/llap-server/src/java/org/apache/hadoop/hive/llap/metrics/LlapDaemonCacheMetrics.java
+++ b/llap-server/src/java/org/apache/hadoop/hive/llap/metrics/LlapDaemonCacheMetrics.java
@@ -18,11 +18,10 @@
 package org.apache.hadoop.hive.llap.metrics;
 
 import static org.apache.hadoop.hive.llap.metrics.LlapDaemonCacheInfo.AllocationAttempt;
-import static org.apache.hadoop.hive.llap.metrics.LlapDaemonCacheInfo.AllocationFromBruteDiscard;
 import static org.apache.hadoop.hive.llap.metrics.LlapDaemonCacheInfo.AllocationFromFreeListDiscard;
 import static org.apache.hadoop.hive.llap.metrics.LlapDaemonCacheInfo.AllocationWithExpand;
 import static org.apache.hadoop.hive.llap.metrics.LlapDaemonCacheInfo.AllocationWithSplits;
-import static org.apache.hadoop.hive.llap.metrics.LlapDaemonCacheInfo.AllocatorBruteForceEvictedBytes;
+import static org.apache.hadoop.hive.llap.metrics.LlapDaemonCacheInfo.AllocatorForceEvictedBlocksBytes;
 import static org.apache.hadoop.hive.llap.metrics.LlapDaemonCacheInfo.AllocatorFastAllocatedBytes;
 import static org.apache.hadoop.hive.llap.metrics.LlapDaemonCacheInfo.AllocatorFreeListEvictedBytes;
 import static org.apache.hadoop.hive.llap.metrics.LlapDaemonCacheInfo.AllocatorTotalAllocated;
@@ -78,9 +77,9 @@
   @Metric
   MutableCounterLong cacheNumLockedBuffers;
   @Metric
-  MutableCounterLong allocatorForceEvictedBytes;
+  MutableCounterLong allocatorForceEvictedBlocksBytes;
   @Metric
-  MutableCounterLong allocatorFreeListEvictedBytes;
+  MutableCounterLong allocatorForcedEvictedBytes;
   @Metric
   MutableCounterLong allocatorTotalAllocatedBytes;
   @Metric
@@ -94,9 +93,7 @@
   @Metric
   MutableCounterLong allocationWithExpand;
   @Metric
-  MutableCounterLong allocationFromFreeListDiscard;
-  @Metric
-  MutableCounterLong allocationFromBruteDiscard;
+  MutableCounterLong allocationEvictionAttempts;
   @Metric
   MutableCounterLong allocationAttempt;
 
@@ -162,12 +159,12 @@ public void incAllocatorTotalBytes(long delta) {
     allocatorTotalAllocatedBytes.incr(delta);
   }
 
-  public void incAllocatorBruteForceEvictedBytes(long delta) {
-    allocatorForceEvictedBytes.incr(delta);
+  public void incAllocatorForceEvictedBlocksBytes(long delta) {
+    allocatorForceEvictedBlocksBytes.incr(delta);
   }
 
-  public void incAllocatorFreeListEvictedBytes(long delta) {
-    allocatorFreeListEvictedBytes.incr(delta);
+  public void incAllocatorForceEvictedBytes(long delta) {
+    allocatorForcedEvictedBytes.incr(delta);
   }
 
   @Override
@@ -195,16 +192,15 @@ private void getCacheStats(MetricsRecordBuilder rb) {
         .addCounter(CacheHitBytes, cacheHitBytes.value())
         .addCounter(CacheAllocatedArena, cacheAllocatedArena.value())
         .addCounter(CacheNumLockedBuffers, cacheNumLockedBuffers.value())
-        .addCounter(AllocatorBruteForceEvictedBytes, allocatorForceEvictedBytes.value())
-        .addCounter(AllocatorFreeListEvictedBytes, allocatorFreeListEvictedBytes.value())
+        .addCounter(AllocatorForceEvictedBlocksBytes, allocatorForceEvictedBlocksBytes.value())
+        .addCounter(AllocatorFreeListEvictedBytes, allocatorForcedEvictedBytes.value())
         .addCounter(AllocatorTotalAllocated, allocatorTotalAllocatedBytes.value())
         .addCounter(CacheEvictedTotalBytes, cacheEvictedBytesTotal.value())
         .addCounter(AllocatorFastAllocatedBytes, allocatorFastAllocBytes.value())
         .addCounter(CacheTotalReserved, cacheTotalReserved.value())
         .addCounter(AllocationWithSplits, allocationWithSplits.value())
         .addCounter(AllocationWithExpand, allocationWithExpand.value())
-        .addCounter(AllocationFromFreeListDiscard, allocationFromFreeListDiscard.value())
-        .addCounter(AllocationFromBruteDiscard, allocationFromBruteDiscard.value())
+        .addCounter(AllocationFromFreeListDiscard, allocationEvictionAttempts.value())
         .addCounter(AllocationAttempt, allocationAttempt.value())
         .addGauge(CacheHitRatio, cacheHitRatio);
   }
@@ -229,12 +225,8 @@ public void incrAllocationWithExpand(long delta) {
     allocationWithExpand.incr(delta);
   }
 
-  public void incrAllocationFromFreeListDiscard(long delta) {
-    allocationFromFreeListDiscard.incr(delta);
-  }
-
-  public void incrAllocationFromBruteDiscard(long delta) {
-    allocationFromBruteDiscard.incr(delta);
+  public void incrAllocationEvictionAttempts(long delta) {
+    allocationEvictionAttempts.incr(delta);
   }
 
   public void incrAllocationAttempt(long delta) {
