commit ddd46eb6bc6fb6220484d6bb846bd5bf0738a976
Author: Slim Bouguerra <bslim@apache.org>
Date:   Sun Mar 24 21:20:13 2019 -0700

    Adding more counters to dispatcher and policy
    
    Change-Id: Ib6eb18971df01c2e6f16a8444a93eca5e4855179

diff --git a/llap-server/src/java/org/apache/hadoop/hive/llap/cache/EvictionDispatcher.java b/llap-server/src/java/org/apache/hadoop/hive/llap/cache/EvictionDispatcher.java
index 10a4bfbb58..06950a6dcc 100644
--- a/llap-server/src/java/org/apache/hadoop/hive/llap/cache/EvictionDispatcher.java
+++ b/llap-server/src/java/org/apache/hadoop/hive/llap/cache/EvictionDispatcher.java
@@ -17,10 +17,23 @@
  */
 package org.apache.hadoop.hive.llap.cache;
 
+import com.google.common.base.MoreObjects;
+import org.apache.hadoop.conf.Configuration;
 import org.apache.hadoop.hive.llap.cache.SerDeLowLevelCacheImpl.LlapSerDeDataBuffer;
 import org.apache.hadoop.hive.llap.io.metadata.OrcFileEstimateErrors;
 import org.apache.hadoop.hive.llap.io.metadata.MetadataCache;
 import org.apache.hadoop.hive.llap.io.metadata.MetadataCache.LlapMetadataBuffer;
+import org.apache.hadoop.hive.llap.metrics.LlapMetricsSystem;
+import org.apache.hadoop.hive.llap.metrics.MetricsUtils;
+import org.apache.hadoop.metrics2.MetricsCollector;
+import org.apache.hadoop.metrics2.MetricsInfo;
+import org.apache.hadoop.metrics2.MetricsRecordBuilder;
+import org.apache.hadoop.metrics2.MetricsSource;
+
+import java.util.concurrent.atomic.LongAdder;
+
+import static org.apache.hadoop.metrics2.impl.MsInfo.ProcessName;
+import static org.apache.hadoop.metrics2.impl.MsInfo.SessionId;
 
 /**
  * Eviction dispatcher - uses double dispatch to route eviction notifications to correct caches.
@@ -30,17 +43,31 @@
   private final SerDeLowLevelCacheImpl serdeCache;
   private final MetadataCache metadataCache;
   private final EvictionAwareAllocator allocator;
+  private final PolicyMetrics metrics;
 
   public EvictionDispatcher(LowLevelCache dataCache, SerDeLowLevelCacheImpl serdeCache,
-      MetadataCache metadataCache, EvictionAwareAllocator allocator) {
+      MetadataCache metadataCache, EvictionAwareAllocator allocator, Configuration conf) {
     this.dataCache = dataCache;
     this.metadataCache = metadataCache;
     this.serdeCache = serdeCache;
     this.allocator = allocator;
+
+    String sessID = conf.get("llap.daemon.metrics.sessionid");
+    if (null == sessID) {
+      sessID = "<unknown>";
+    }
+    metrics = new PolicyMetrics(sessID);
+    LlapMetricsSystem.instance()
+        .register("EvictionDispatcher-" + MetricsUtils.getHostName(), "LlapDaemon Caching Metrics", metrics);
   }
 
   @Override
   public void notifyEvicted(LlapCacheableBuffer buffer) {
+    if (buffer instanceof LlapMetadataBuffer) {
+      metrics.incEvictionsMetadataBytes(buffer.getMemoryUsage());
+    } else if (buffer instanceof LlapDataBuffer) {
+      metrics.incEvictionsData(buffer.getMemoryUsage());
+    }
     buffer.notifyEvicted(this); // This will call one of the specific notifyEvicted overloads.
   }
 
@@ -86,4 +113,56 @@ public void debugDumpShort(StringBuilder sb) {
       metadataCache.debugDumpShort(sb);
     }
   }
+
+  private class PolicyMetrics implements MetricsSource {
+    private final LongAdder evictionsDataBytes = new LongAdder();
+    private final LongAdder evictionMetadataBytes = new LongAdder();
+    private final String sessionId;
+
+    private PolicyMetrics(String sessionId) {
+      this.sessionId = sessionId;
+    }
+
+    @Override public void getMetrics(MetricsCollector metricsCollector, boolean b) {
+      MetricsRecordBuilder rb = metricsCollector.addRecord(PolicyInformation.EvictionDispatcher)
+          .setContext("cache")
+          .tag(ProcessName, MetricsUtils.METRICS_PROCESS_NAME)
+          .tag(SessionId, sessionId);
+
+      getCacheStats(rb);
+    }
+
+    private void getCacheStats(MetricsRecordBuilder rb) {
+      rb.addCounter(PolicyInformation.EvictionDispatcherDataBytes, evictionsDataBytes.sum())
+          .addCounter(PolicyInformation.EvictionDispatcherMetaDataBytes, evictionMetadataBytes.sum());
+    }
+
+    void incEvictionsData(long delta) {
+      evictionsDataBytes.add(delta);
+    }
+
+    void incEvictionsMetadataBytes(long delta) {
+      evictionMetadataBytes.add(delta);
+    }
+  }
+
+  private enum PolicyInformation implements MetricsInfo {
+    EvictionDispatcher("EvictionDispatcher related info"),
+    EvictionDispatcherDataBytes("Data evicted bytes"),
+    EvictionDispatcherMetaDataBytes("MetaData Evicted bytes");
+
+    private String desc;
+
+    PolicyInformation(String desc) {
+      this.desc = desc;
+    }
+
+    @Override public String description() {
+      return desc;
+    }
+
+    @Override public String toString() {
+      return MoreObjects.toStringHelper(this).add("name", name()).add("description", desc).toString();
+    }
+  }
 }
diff --git a/llap-server/src/java/org/apache/hadoop/hive/llap/cache/LowLevelLrfuCachePolicy.java b/llap-server/src/java/org/apache/hadoop/hive/llap/cache/LowLevelLrfuCachePolicy.java
index 0e9a1a4d66..5bfabadd83 100644
--- a/llap-server/src/java/org/apache/hadoop/hive/llap/cache/LowLevelLrfuCachePolicy.java
+++ b/llap-server/src/java/org/apache/hadoop/hive/llap/cache/LowLevelLrfuCachePolicy.java
@@ -19,8 +19,10 @@
 package org.apache.hadoop.hive.llap.cache;
 
 import java.util.concurrent.atomic.AtomicLong;
+import java.util.concurrent.atomic.LongAdder;
 import java.util.concurrent.locks.ReentrantLock;
 
+import com.google.common.base.MoreObjects;
 import org.apache.commons.lang.StringUtils;
 import org.apache.hadoop.conf.Configuration;
 import org.apache.hadoop.hive.conf.HiveConf;
@@ -28,6 +30,15 @@
 import org.apache.hadoop.hive.llap.cache.LowLevelCache.Priority;
 import org.apache.hadoop.hive.llap.io.api.impl.LlapIoImpl;
 import org.apache.hadoop.hive.llap.io.metadata.MetadataCache;
+import org.apache.hadoop.hive.llap.metrics.LlapMetricsSystem;
+import org.apache.hadoop.hive.llap.metrics.MetricsUtils;
+import org.apache.hadoop.metrics2.MetricsCollector;
+import org.apache.hadoop.metrics2.MetricsInfo;
+import org.apache.hadoop.metrics2.MetricsRecordBuilder;
+import org.apache.hadoop.metrics2.MetricsSource;
+
+import static org.apache.hadoop.metrics2.impl.MsInfo.ProcessName;
+import static org.apache.hadoop.metrics2.impl.MsInfo.SessionId;
 
 /**
  * Implementation of the algorithm from "On the Existence of a Spectrum of Policies
@@ -67,6 +78,7 @@ private final double expirePriority(long time, long lastAccess, double previous)
   private final int maxHeapSize;
   private EvictionListener evictionListener;
   private LlapOomDebugDump parentDebugDump;
+  private final PolicyMetrics metrics;
 
   public LowLevelLrfuCachePolicy(int minBufferSize, long maxSize, Configuration conf) {
     lambda = HiveConf.getFloatVar(conf, HiveConf.ConfVars.LLAP_LRFU_LAMBDA);
@@ -82,6 +94,14 @@ public LowLevelLrfuCachePolicy(int minBufferSize, long maxSize, Configuration co
 
     heap = new LlapCacheableBuffer[maxHeapSize];
     listHead = listTail = null;
+
+    String sessID = conf.get("llap.daemon.metrics.sessionid");
+    if (null == sessID) {
+       sessID = "<unknown>";
+      }
+    metrics = new PolicyMetrics(sessID);
+    LlapMetricsSystem.instance()
+        .register("LowLevelLrfuCachePolicy-" + MetricsUtils.getHostName(), "LlapDaemon Caching Metrics", metrics);
   }
 
   @Override
@@ -234,6 +254,7 @@ public long purge() {
     }
     LlapIoImpl.LOG.info("PURGE: evicted {} from LRFU policy",
         LlapUtil.humanReadableByteCount(evicted));
+    metrics.incrEvicted(evicted);
     return evicted;
   }
 
@@ -256,6 +277,7 @@ private static LlapCacheableBuffer removeFromLocalList(
   public long evictSomeBlocks(long memoryToReserve) {
     // In normal case, we evict the items from the list.
     long evicted = evictFromList(memoryToReserve);
+    metrics.incrEvicted(evicted);
     if (evicted >= memoryToReserve) return evicted;
     // This should not happen unless we are evicting a lot at once, or buffers are large (so
     // there's a small number of buffers and they all live in the heap).
@@ -269,6 +291,7 @@ public long evictSomeBlocks(long memoryToReserve) {
       evicted += buffer.getMemoryUsage();
       evictionListener.notifyEvicted(buffer);
     }
+    metrics.incrEvicted(evicted);
     return evicted;
   }
 
@@ -592,4 +615,48 @@ public void debugDumpShort(StringBuilder sb) {
       parentDebugDump.debugDumpShort(sb);
     }
   }
+
+  private enum PolicyInformation implements MetricsInfo {
+    LRFU("Policy related info"), CachePolicyEvictedBytes("Bytes evicted by cache policy");
+
+    private String desc;
+
+    PolicyInformation(String desc) {
+      this.desc = desc;
+    }
+
+    @Override public String description() {
+      return desc;
+    }
+
+    @Override public String toString() {
+      return MoreObjects.toStringHelper(this).add("name", name()).add("description", desc).toString();
+    }
+  }
+  private class PolicyMetrics implements MetricsSource {
+
+    private final String sessionId;
+    private final LongAdder evictedBytes = new LongAdder();
+    public PolicyMetrics(String sessionId) {
+      this.sessionId = sessionId;
+    }
+
+    void incrEvicted(long delta) {
+      evictedBytes.add(delta);
+    }
+
+    @Override public void getMetrics(MetricsCollector metricsCollector, boolean b) {
+
+      MetricsRecordBuilder rb = metricsCollector.addRecord(PolicyInformation.LRFU)
+          .setContext("cache")
+          .tag(ProcessName, MetricsUtils.METRICS_PROCESS_NAME)
+          .tag(SessionId, sessionId);
+
+      getCacheStats(rb);
+    }
+
+    private void getCacheStats(MetricsRecordBuilder rb) {
+      rb.addCounter(PolicyInformation.CachePolicyEvictedBytes, evictedBytes.sum());
+    }
+  }
 }
diff --git a/llap-server/src/java/org/apache/hadoop/hive/llap/io/api/impl/LlapIoImpl.java b/llap-server/src/java/org/apache/hadoop/hive/llap/io/api/impl/LlapIoImpl.java
index ea9b996db4..f1dfa89933 100644
--- a/llap-server/src/java/org/apache/hadoop/hive/llap/io/api/impl/LlapIoImpl.java
+++ b/llap-server/src/java/org/apache/hadoop/hive/llap/io/api/impl/LlapIoImpl.java
@@ -173,7 +173,7 @@ private LlapIoImpl(Configuration conf) throws IOException {
       fileMetadataCache = metadataCache;
       // And finally cache policy uses cache to notify it of eviction. The cycle is complete!
       EvictionDispatcher e = new EvictionDispatcher(
-          dataCache, serdeCache, metadataCache, allocator);
+          dataCache, serdeCache, metadataCache, allocator, conf);
       cachePolicyWrapper.setEvictionListener(e);
       cachePolicyWrapper.setParentDebugDumper(e);
 
