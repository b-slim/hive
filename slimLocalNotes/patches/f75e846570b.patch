commit f75e846570b091b2861983e55b1aa4e1ba7e71a4
Author: Slim Bouguerra <bslim@apache.org>
Date:   Tue Mar 26 17:08:18 2019 -0700

    adding wip to evict n blocks and retry allocate fast
    
    Change-Id: I96daa5395d179749d13495c81649e1f35b606f6a

diff --git a/llap-server/src/java/org/apache/hadoop/hive/llap/cache/BuddyAllocator.java b/llap-server/src/java/org/apache/hadoop/hive/llap/cache/BuddyAllocator.java
index 383fa8db29..1c8f97bd6f 100644
--- a/llap-server/src/java/org/apache/hadoop/hive/llap/cache/BuddyAllocator.java
+++ b/llap-server/src/java/org/apache/hadoop/hive/llap/cache/BuddyAllocator.java
@@ -276,11 +276,59 @@ public void allocateMultiple(MemoryBuffer[] dest, int size, BufferObjectFactory
 
     // Note: we might want to be smarter if threadId-s are low and there more arenas than threads.
     long threadId = arenaCount > 1 ? Thread.currentThread().getId() : 0;
-    int destAllocIx = allocateFast(dest, null, 0, dest.length,
-        freeListIx, allocationSize, (int)(threadId % arenaCount), arenaCount);
-    metrics.incAllocatorFastAllocation(destAllocIx * allocationSize);
-    if (destAllocIx == dest.length) return;
+    int startArenaIx = (int)(threadId  % arenaCount);
+    int prevAllocIx = 0;
+    int destAllocIx = 0;
+    int fastAttempt = 0;
+    int forceEvictedBlocks = 0;
+    while (fastAttempt < MAX_DISCARD_ATTEMPTS) {
+      destAllocIx =
+          allocateFast(dest,
+              null,
+              destAllocIx,
+              dest.length,
+              freeListIx,
+              allocationSize,
+              (int) (threadId % arenaCount),
+              arenaCount);
+      metrics.incAllocatorFastAllocation((destAllocIx - prevAllocIx) * allocationSize);
+      if (destAllocIx == dest.length)
+        return;
+
+      destAllocIx =
+          allocateWithSplit(dest,
+              null,
+              destAllocIx,
+              dest.length,
+              freeListIx,
+              allocationSize,
+              startArenaIx,
+              arenaCount,
+              -1);
+      metrics.incrAllocationWithSplits((destAllocIx - prevAllocIx) * allocationSize);
+      if (destAllocIx == dest.length)
+        return;
+
+      forceEvictedBlocks += memoryManager.evictNBlocks(allocationSize, dest.length - destAllocIx);
+      fastAttempt ++;
+      metrics.incAllocatorBruteForceEvictedBytes(forceEvictedBlocks * allocationSize);
+      metrics.incrAllocationAttempt(1);
+    }
 
+    if (forceEvictedBlocks > 0 ) //noinspection Duplicates
+    {
+      for (int i = 0; i < destAllocIx; ++i) {
+        try {
+          deallocate(dest[i]);
+        } catch (Throwable t) {
+          LlapIoImpl.LOG.info("Failed to deallocate after a partially successful allocate: " + dest[i]);
+        }
+      }
+      String msg = "Failed to allocate " + size + "; at " + destAllocIx + " out of "
+          + dest.length + " (entire cache is fragmented and locked, or an internal issue)";
+      logOomErrorMessage(msg);
+      throw new AllocatorOutOfMemoryException(msg);
+    }
     // We called reserveMemory so we know that there's memory waiting for us somewhere.
     // However, we have a class of rare race conditions related to the order of locking/checking of
     // different allocation areas. Simple case - say we have 2 arenas, 256Kb available in arena 2.
@@ -303,13 +351,13 @@ public void allocateMultiple(MemoryBuffer[] dest, int size, BufferObjectFactory
     try {
       int discardFailed = 0;
       while (true) {
-        // Try to split bigger blocks.
+       /* // Try to split bigger blocks.
         int startArenaIx = (int)((threadId + attempt) % arenaCount);
         int prevAllocIx = destAllocIx;
         destAllocIx = allocateWithSplit(dest, null, destAllocIx, dest.length,
             freeListIx, allocationSize, startArenaIx, arenaCount, -1);
         metrics.incrAllocationWithSplits((destAllocIx - prevAllocIx ) * allocationSize);
-        if (destAllocIx == dest.length) return;
+        if (destAllocIx == dest.length) return;*/
 
         if (attempt == 0) {
           // Try to allocate memory if we haven't allocated all the way to maxSize yet; very rare.
@@ -333,8 +381,7 @@ public void allocateMultiple(MemoryBuffer[] dest, int size, BufferObjectFactory
           memoryFreeListReleased += ctx.memoryReleased;
           hasDiscardedAny = ctx.resultCount > 0;
           prevAllocIx = destAllocIx;
-          destAllocIx = allocateFromDiscardResult(
-              dest, destAllocIx, freeListIx, allocationSize, ctx);
+          destAllocIx = allocateFromDiscardResult(dest, destAllocIx, freeListIx, allocationSize, ctx);
           metrics.incrAllocationFromFreeListDiscard((destAllocIx - prevAllocIx ) * allocationSize);
           if (destAllocIx == dest.length) return;
         }
@@ -345,8 +392,7 @@ public void allocateMultiple(MemoryBuffer[] dest, int size, BufferObjectFactory
           memoryBruteForceReleased += ctx.memoryReleased;
           hasDiscardedAny = hasDiscardedAny || (ctx.resultCount > 0);
           prevAllocIx = destAllocIx;
-          destAllocIx = allocateFromDiscardResult(
-              dest, destAllocIx, freeListIx, allocationSize, ctx);
+          destAllocIx = allocateFromDiscardResult(dest, destAllocIx, freeListIx, allocationSize, ctx);
           metrics.incrAllocationFromBruteDiscard((destAllocIx - prevAllocIx ) * allocationSize);
           if (destAllocIx == dest.length) return;
         }
@@ -1209,8 +1255,7 @@ private int allocateFast(int freeListIx, MemoryBuffer[] dest, long[] destHeaders
       FreeList freeList = freeLists[freeListIx];
       if (!freeList.lock.tryLock()) return destIx;
       try {
-        return allocateFromFreeListUnderLock(
-            freeList, freeListIx, dest, destHeaders, destIx, destCount, allocSize);
+        return allocateFromFreeListUnderLock(freeList, freeListIx, dest, destHeaders, destIx, destCount, allocSize);
       } finally {
         freeList.lock.unlock();
       }
diff --git a/llap-server/src/java/org/apache/hadoop/hive/llap/cache/BuddyAllocatorMXBean.java b/llap-server/src/java/org/apache/hadoop/hive/llap/cache/BuddyAllocatorMXBean.java
index 5e3cc50c1b..276431cd07 100644
--- a/llap-server/src/java/org/apache/hadoop/hive/llap/cache/BuddyAllocatorMXBean.java
+++ b/llap-server/src/java/org/apache/hadoop/hive/llap/cache/BuddyAllocatorMXBean.java
@@ -30,33 +30,49 @@
    *
    * @return gets if direct bytebuffer allocation
    */
-  public boolean getIsDirect();
+  boolean getIsDirect();
 
   /**
    * Gets minimum allocation size of allocator.
    *
    * @return minimum allocation size
    */
-  public int getMinAllocation();
+  int getMinAllocation();
 
   /**
    * Gets maximum allocation size of allocator.
    *
    * @return maximum allocation size
    */
-  public int getMaxAllocation();
+  int getMaxAllocation();
 
   /**
    * Gets the arena size.
    *
    * @return arena size
    */
-  public int getArenaSize();
+  int getArenaSize();
 
   /**
    * Gets the maximum cache size.
    *
    * @return max cache size
    */
-  public long getMaxCacheSize();
+  long getMaxCacheSize();
+
+  default long getTotalAllocated() {
+    return  -1;
+  }
+
+  default long getBrutForceDiscarded() {
+    return -1;
+  }
+
+  default long getFastAllocated() {
+    return -1;
+  }
+
+  default long getFreeListDiscardedBytes() {
+    return -1;
+  }
 }
\ No newline at end of file
diff --git a/llap-server/src/java/org/apache/hadoop/hive/llap/cache/LowLevelCacheMemoryManager.java b/llap-server/src/java/org/apache/hadoop/hive/llap/cache/LowLevelCacheMemoryManager.java
index 9a84897daa..6fb79faeb7 100644
--- a/llap-server/src/java/org/apache/hadoop/hive/llap/cache/LowLevelCacheMemoryManager.java
+++ b/llap-server/src/java/org/apache/hadoop/hive/llap/cache/LowLevelCacheMemoryManager.java
@@ -66,6 +66,20 @@ public void reserveMemory(final long memoryToReserve, AtomicBoolean isStopped) {
     throw new ReserveFailedException(isStopped);
   }
 
+  /**
+   * @param blockSize target block size to be evicted
+   * @param n         number of blocks
+   * @return actual number of evicted blocks
+   */
+  @Override
+  public int evictNBlocks(long blockSize, int n) {
+    int evicted = evictor.evictNBlocks(blockSize, n);
+    if (evicted > 0 ) {
+      releaseMemory(evicted * blockSize);
+    }
+    return evicted;
+  }
+
   @VisibleForTesting
   public boolean reserveMemory(final long memoryToReserve,
       boolean waitForEviction, AtomicBoolean isStopped) {
diff --git a/llap-server/src/java/org/apache/hadoop/hive/llap/cache/LowLevelCachePolicy.java b/llap-server/src/java/org/apache/hadoop/hive/llap/cache/LowLevelCachePolicy.java
index 33236362b5..848777277c 100644
--- a/llap-server/src/java/org/apache/hadoop/hive/llap/cache/LowLevelCachePolicy.java
+++ b/llap-server/src/java/org/apache/hadoop/hive/llap/cache/LowLevelCachePolicy.java
@@ -22,10 +22,20 @@
 
 public interface LowLevelCachePolicy extends LlapOomDebugDump {
   void cache(LlapCacheableBuffer buffer, Priority priority);
+
   void notifyLock(LlapCacheableBuffer buffer);
+
   void notifyUnlock(LlapCacheableBuffer buffer);
+
   long evictSomeBlocks(long memoryToReserve);
+
   void setEvictionListener(EvictionListener listener);
+
   void setParentDebugDumper(LlapOomDebugDump dumper);
+
   long purge();
+
+  default int evictNBlocks(long blockSize, int n) {
+    return 0;
+  }
 }
diff --git a/llap-server/src/java/org/apache/hadoop/hive/llap/cache/LowLevelLrfuCachePolicy.java b/llap-server/src/java/org/apache/hadoop/hive/llap/cache/LowLevelLrfuCachePolicy.java
index 5bfabadd83..26909b93fb 100644
--- a/llap-server/src/java/org/apache/hadoop/hive/llap/cache/LowLevelLrfuCachePolicy.java
+++ b/llap-server/src/java/org/apache/hadoop/hive/llap/cache/LowLevelLrfuCachePolicy.java
@@ -295,6 +295,65 @@ public long evictSomeBlocks(long memoryToReserve) {
     return evicted;
   }
 
+  @Override
+  public int evictNBlocks(long blockSize, int n) {
+    // try to evict from the list first
+    int evicted = evictNBlocksFromList(blockSize, n);
+    if (evicted == n) {
+      return  n;
+    }
+    evicted = evictNBlocksFromHeap(blockSize, n - evicted);
+    // try to evict from the heap
+    return evicted;
+  }
+
+  private int evictNBlocksFromHeap(long blockSize, int n) {
+    long time = timer.get();
+    int j = 0;
+    synchronized (heapLock) {
+      int i = 0;
+      //Double check this -> assuming heapSize does not change when i am at the synchronized heapLock block
+      while (i < heapSize && j < n) {
+        if (heap[i].getMemoryUsage() == blockSize) {
+          LlapCacheableBuffer buffer = evictHeapElementUnderLock(time, i);
+          if (buffer !=  null) {
+            evictionListener.notifyEvicted(buffer);
+            j++;
+          }
+        }
+      }
+
+    }
+    return j;
+  }
+
+  /**
+   * @param blockSize block size to be evicted
+   * @param n number of blocks to be evicted
+   * @return number of evicted blocks
+   */
+  private int evictNBlocksFromList(long blockSize, int n) {
+    int evictedBlocks = 0;
+    LlapCacheableBuffer nextCandidate;
+    listLock.lock();
+    try {
+      nextCandidate = listTail;
+      while (evictedBlocks < n && nextCandidate != null) {
+        if (nextCandidate.getMemoryUsage() == blockSize
+            && LlapCacheableBuffer.INVALIDATE_OK == nextCandidate.invalidate()) {
+          evictedBlocks += 1;
+          removeFromListUnderLock(nextCandidate);
+          evictionListener.notifyEvicted(nextCandidate);
+        }
+        nextCandidate = nextCandidate.prev;
+
+      }
+    } finally {
+      listLock.unlock();
+    }
+    return evictedBlocks;
+  }
+
   private long evictFromList(long memoryToReserve) {
     long evicted = 0;
     LlapCacheableBuffer nextCandidate = null, firstCandidate = null;
diff --git a/llap-server/src/java/org/apache/hadoop/hive/llap/cache/MemoryManager.java b/llap-server/src/java/org/apache/hadoop/hive/llap/cache/MemoryManager.java
index 3c7ce273d0..e3064287f5 100644
--- a/llap-server/src/java/org/apache/hadoop/hive/llap/cache/MemoryManager.java
+++ b/llap-server/src/java/org/apache/hadoop/hive/llap/cache/MemoryManager.java
@@ -57,4 +57,13 @@
    *                        allocate the space.
    */
   void reserveMemory(long memoryToReserve, AtomicBoolean isStopped);
+
+  /**
+   * @param blockSize target block size to be evicted
+   * @param n number of blocks
+   * @return actual number of evicted blocks
+   */
+  default int evictNBlocks(long blockSize, int n) {
+    return 0;
+  }
 }
